package lyc.compiler;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import java_cup.runtime.*;
import lyc.compiler.table.*;
import lyc.compiler.model.*;

import lyc.compiler.tercetos.*;
import lyc.compiler.files.*;
import java.util.Stack;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
class Parser;

action code
{:
    /**** Tabla de simbolos ****/
    public SymbolTable symbolTable = new SymbolTable();
    public ArrayList<Simbolo> symbolList = new ArrayList<>();

    /**** Tercetos ****/
    public ArrayList<Tercetos> listaDeTercetos = new ArrayList<>();
    public Stack<Integer> tercetoStack = new Stack<>();
    public Stack<Integer> numerosDeTercetosStack = new Stack<>();

    public IntermediateCodeGenerator intermediateCode = new IntermediateCodeGenerator(listaDeTercetos);
    public ManejadorTercetos manejador_Tercetos = new ManejadorTercetos();
    
    Map<Integer, String> mapaTiposTercetos = new HashMap<>();
    public int indexTerceto = 1;
    public int indexTercetoInicial;
    String operadorContrario = "";
    public int terceto_salto = 0;

    public String invertirOperador(String operador) {
    switch (operador) {
        case "BGE": return "BLT";  // Mayor o igual -> Menor
        case "BLE": return "BGT";  // Menor o igual -> Mayor
        case "BGT": return "BLE";  // Mayor -> Menor o igual
        case "BLT": return "BGE";  // Menor -> Mayor o igual
        case "BEQ": return "BNE";  // Igual -> No igual
        case "BNE": return "BEQ";  // No igual -> Igual
        default: throw new RuntimeException("Operador no válido para inversión: " + operador);
    }
}
:}

parser code
{:
    public ArrayList<Simbolo> getSymbolTable() { 
        return action_obj.symbolTable.getSymbolTable();
    }

    public ArrayList<Tercetos> getIntermediateCode() {
            return action_obj.manejador_Tercetos.getIntermediateCode();
    }

:}

// Terminals
terminal ASSIG;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal INTEGER_CONSTANT;
terminal IDENTIFIER;
terminal DATE_CONVERTED;
terminal CA_CA;					
terminal CA_CC;					
terminal CA_LA;					
terminal CA_LC;					
terminal CA_CO;					
terminal CA_DP;					
terminal CA_PY;
terminal CP_BITT;
terminal CP_BITF;
terminal CA_COM;		

terminal CP_MEN;					
terminal CP_MENI;					
terminal CP_MAY;					
terminal CP_MAYI;					
terminal CP_IGUA;					
terminal CP_DIST;					
terminal CP_Y;					
terminal CP_O;					
terminal CP_NO;					
terminal CONST_STR;              
terminal CONST_FLO;             	
                
terminal INT;						
terminal FLOAT;					
terminal STRING;					
terminal INI;						
terminal IF;						
terminal ELSE;					
terminal WRITE;					
terminal READ;					
terminal WHILE;					
terminal TAM;						
terminal CONV;

// Non Terminals
non terminal programa;
non terminal iniciar;
non terminal lista_sentencia;
non terminal lista_declaracion;
non terminal declaracion;
non terminal lista_ids;
non terminal tipo_dato;
non terminal sentence;
non terminal assignment;
non terminal expression;
non terminal term;
non terminal factor;
non terminal condicion;
non terminal conjunto_condicion;
non terminal condicion_simple;
non terminal condicion_multiple;
non terminal condicion_negada;
non terminal operador_logico;
non terminal escribe;
non terminal lista_cartesiana;
non terminal triangulo;
non terminal punto;
non terminal eje;
non terminal fecha;
non terminal dia;
non terminal mes;
non terminal anio;

/*
	TEMAS COMUNES:
	A: While
	B: If / if - else
	C: Asignaciones
	D: Operaciones Aritméticas
	E: Tipos de datos
	F: Declaración de variables
	G: Entrada y salida
	H: Condiciones

	TEMAS ESPECIALES
	Z: triangleAreaMaximum
	X: convDate
*/

// ========================================================================== //
// ================ Comienzo del programa
// ========================================================================== //
start with programa;

programa ::= iniciar lista_sentencia;
// ========================================================================== //
// ================ F: Declaración de variables
// ========================================================================== //

iniciar ::= INI CA_LA lista_declaracion CA_LC
{:System.out.println("Inicializacion: completado");:};

lista_declaracion ::= lista_declaracion declaracion | 
					declaracion;

declaracion ::= lista_ids CA_DP tipo_dato
{: System.out.println("Declaracion: completado"); :};

lista_ids ::= lista_ids CA_CO IDENTIFIER:id
{: 
// Verificar si la variable ya está en la tabla de símbolos
    if (action_obj.symbolTable.containsSymbol(id.toString())) {
        throw new RuntimeException("Error: La variable '" + id.toString() + "' ya está declarada.");
    }

    // Crear y agregar la nueva variable
    Simbolo symbol = new Simbolo(id.toString(), "", "", null);
    this.symbolList.add(symbol);
    System.out.println("Se inicializó la variable: " + id.toString());
 :} | 
				IDENTIFIER:id
				{: 
				// Verificar si la variable ya está en la tabla de símbolos
				if (action_obj.symbolTable.containsSymbol(id.toString())) {
					throw new RuntimeException("Error: La variable '" + id.toString() + "' ya está declarada.");
				}

				// Crear y agregar la nueva variable
				Simbolo symbol = new Simbolo(id.toString(), "", "", null);
				this.symbolList.add(symbol);
				System.out.println("Se inicializó la variable: " + id.toString());
				:};
			
lista_sentencia ::= lista_sentencia sentence | 
				sentence;

// ========================================================================== //
// ================ C: Asignaciones
// ========================================================================== //

sentence ::= assignment;
assignment ::= IDENTIFIER:id ASSIG expression:e
{:
    // Validar existencia de la variable LHS
    Simbolo var = action_obj.symbolTable.getSymbol(id.toString());
    if (var == null) {
        throw new RuntimeException("La variable '" + id + "' no fue declarada.");
    }
    // Validar que la expresión haya propagado un Simbolo tipado
    if (e == null) {
        throw new RuntimeException("Expresión nula en asignación a '" + id + "'.");
    }
    String tVar = var.getTipoDato();
    String tExp = ((Simbolo)e).getTipoDato();
    if (!tExp.equals("DATE_CONVERTED") && !tVar.equals("DATE_CONVERTED") && !tVar.equals(tExp)) {
        throw new RuntimeException("Type mismatch: no se puede asignar " + tExp + " a variable " + id + " de tipo " + tVar);
    }

    System.out.println("Asignacion de : " + id);
:};

// ========================================================================== //
// ================ D: Operaciones Aritméticas
// ========================================================================== //
expression ::= expression:e1 PLUS term:e2
{:
    // Chequeo de tipos homogéneos (no hay promoción implícita)
    if (!((Simbolo)e1).getTipoDato().equals(((Simbolo)e2).getTipoDato())) {
        throw new RuntimeException("Type mismatch en suma: " + ((Simbolo)e1).getTipoDato() + " + " + ((Simbolo)e2).getTipoDato());
    }
    // Propagamos tipo
    RESULT = (Simbolo)e2;
    System.out.println("+");
:};
expression ::= expression:e1 SUB term:e2
{:
    if (!((Simbolo)e1).getTipoDato().equals(((Simbolo)e2).getTipoDato())) {
        throw new RuntimeException("Type mismatch en resta: " + ((Simbolo)e1).getTipoDato() + " - " + ((Simbolo)e2).getTipoDato());
    }
    RESULT = (Simbolo)e2;
    System.out.println("-");
:};
expression ::= term:t
{:
    RESULT = t;
:};
term ::= term:t MULT factor:f
{:
    if (!((Simbolo)t).getTipoDato().equals(((Simbolo)f).getTipoDato())) {
        throw new RuntimeException("Type mismatch en multiplicación: " + ((Simbolo)t).getTipoDato() + " * " + ((Simbolo)f).getTipoDato());
    }
    RESULT = (Simbolo)f;
    System.out.println("*");
:};
term ::= term:t DIV factor:f
{:
    if (!((Simbolo)t).getTipoDato().equals(((Simbolo)f).getTipoDato())) {
        throw new RuntimeException("Type mismatch en división: " + ((Simbolo)t).getTipoDato() + " / " + ((Simbolo)f).getTipoDato());
    }
    RESULT = (Simbolo)f;
    System.out.println("/");
:};
term ::= factor:f
{:
    RESULT = f;
:};
factor ::= IDENTIFIER:id
{:
    // Lookup de variable
    Simbolo s = action_obj.symbolTable.getSymbol(id.toString());
    if (s == null) {
        throw new RuntimeException("La variable '" + id + "' no fue declarada.");
    }
    RESULT = s;
    System.out.println("Id: " + id);
:};
factor ::= INTEGER_CONSTANT:constant
{:
    // Registrar constante entera con prefijo "_"
    String lex = constant.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "Int", lex, null));
    }
    RESULT = new Simbolo(nombre, "Int", lex, null);
    System.out.println("Entero: " + constant );
:};
factor ::= CONST_FLO:f
{:
    String lex = f.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "Float", lex, null));
    }
    RESULT = new Simbolo(nombre, "Float", lex, null);
    System.out.println("Flotante: " + f );
:};
factor ::= CONST_STR:s
{:
    String lex = s.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "String", lex, lex.length()-2));
    }
    RESULT = new Simbolo(nombre, "String", lex, lex.length()-2);
    System.out.println("Cadena: " + s );
:};
factor ::= OPEN_BRACKET expression:e CLOSE_BRACKET
{:
    RESULT = e;
    System.out.println("(Expression)");
:};


/* === Agregados para usar las funciones en expresiones ===
   No se crean entradas en la TS; solo se retorna un Simbolo con el tipo correcto.
   Esto permite, por ejemplo: a = CONV(12-12-2025) y x = TAM([...]) en contextos aritméticos.
*/

// triangleAreaMaximum -> resultado numérico (usamos Float)
factor ::= TAM OPEN_BRACKET lista_cartesiana CLOSE_BRACKET
{:
    // 'lista_cartesiana' ya valida que las coordenadas sean Int/Float y que los IDs existan.
    RESULT = new Simbolo("triangleAreaMaximumResult", "Float", "", 0);
    System.out.println("triangleAreaMaximum usado como factor");
:};

// convDate -> entero YYYYMMDD
factor ::= CONV OPEN_BRACKET fecha CLOSE_BRACKET
{:
    // 'fecha' se define como dia SUB mes SUB anio; tokens enteros.
    RESULT = new Simbolo("convDateResult", "Int", "", 0);
    System.out.println("convDate usado como factor");
:};

// ========================================================================== //
// ================ H: Condiciones
// ========================================================================== //

condicion ::= OPEN_BRACKET conjunto_condicion CLOSE_BRACKET
{:
    System.out.println("Condicion: completado");
:};

conjunto_condicion ::= condicion_simple
                    | condicion_multiple
                    | condicion_negada;

condicion_simple ::= expression:e1 operador_logico expression:e2
{:
    // Validar que ambos lados estén tipados y sean comparables (mismo tipo)
    if (e1 == null || e2 == null) {
        throw new RuntimeException("Expresión nula en condición simple.");
    }
    String t1 = ((Simbolo)e1).getTipoDato();
    String t2 = ((Simbolo)e2).getTipoDato();
    if (!t1.equals(t2)) {
        throw new RuntimeException("Type mismatch en comparación: " + t1 + " con " + t2);
    }
:};

condicion_multiple ::= condicion_simple:cs CP_Y condicion_simple 
{:
    System.out.println("Condicion Multiple con AND");
:}
                    |  condicion_simple:cs CP_O condicion_simple 
{:
    System.out.println("Condicion Multiple con OR");
:};

condicion_negada ::= CP_NO condicion_simple
{:
    System.out.println("Condicion Simple Negada");
:};

operador_logico ::= CP_MEN {:System.out.println("Operador: <"); :} |
CP_MENI {:System.out.println("Operador: <="); :}         | 
CP_MAY {:System.out.println("Operador: >"); :}           |
CP_MAYI {:System.out.println("Operador: >="); :}         |
CP_IGUA {:System.out.println("Operador: =="); :}         |
CP_DIST {:System.out.println("Operador: !="); :};

// ========================================================================== //
// ================ G: Entrada y salida
// ========================================================================== //
sentence ::= READ OPEN_BRACKET IDENTIFIER:id CLOSE_BRACKET
{:
    // Validar existencia del identificador
    if (!action_obj.symbolTable.containsSymbol(id.toString())) {
        throw new RuntimeException("READ sobre variable no declarada: " + id);
    }
    System.out.println("READ: " + id + " completado");
:};
sentence ::= WRITE OPEN_BRACKET escribe CLOSE_BRACKET
{:
    System.out.println("WRITE: completado");
:};

escribe ::= CONST_STR:s
{:
    // Registrar la constante string con prefijo "_"
    String lex = s.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "String", lex, lex.length()-2));
    }
    System.out.println("Cadena: " + s);
:}
          | IDENTIFIER:id
{:
    if (!action_obj.symbolTable.containsSymbol(id.toString())) {
        throw new RuntimeException("WRITE sobre variable no declarada: " + id);
    }
    System.out.println("Id: " + id);
:};
			
// ========================================================================== //
// ================ B: If / if - else
// ========================================================================== //
sentence ::= IF condicion CA_LA lista_sentencia CA_LC 
{:
    System.out.println("IF: completado");
:}
            | IF condicion CA_LA lista_sentencia CA_LC ELSE CA_LA lista_sentencia CA_LC
{:
    System.out.println("IF / ELSE: completado");
:};

// ========================================================================== //
// ================ A: While
// ========================================================================== //

sentence ::= WHILE condicion CA_LA lista_sentencia CA_LC 
{:
    System.out.println("WHILE: completado");
:};


// ========================================================================== //
// ================ E: Tipos de datos
// ========================================================================== //

tipo_dato ::= INT:i {: System.out.println("int" );
			action_obj.symbolTable.addNewSymbols(this.symbolList, "Int");
			this.symbolList.clear();  :} 
			| FLOAT:f {: System.out.println("float"); 
			action_obj.symbolTable.addNewSymbols(this.symbolList, "Float");
			this.symbolList.clear(); :} 
			| STRING:s {: System.out.println("string"); 
			action_obj.symbolTable.addNewSymbols(this.symbolList, "String");
			this.symbolList.clear(); :}
			| DATE_CONVERTED:d {: System.out.println("DATE_CONVERTED"); 
			action_obj.symbolTable.addNewSymbols(this.symbolList, "DATE_CONVERTED");
			this.symbolList.clear(); :} ;


// ========================================================================== //
// ================ Z: triangleAreaMaximum
// ========================================================================== //
/*
triangleAreaMaximum

Se desea implementar una función llamada triangleAreaMaximum que, dadas las 
coordenadas de dos triángulos en el plano cartesiano, determine cuál de los 
dos tiene mayor área y devuelva dicho valor numérico.

La función recibirá dos triángulos, cada uno definido por las coordenadas 
de sus vértices en el plano cartesiano. Dichas coordenadas pueden ser 
Constantes o Variables, enteras o flotantes.
*/
sentence ::= TAM OPEN_BRACKET lista_cartesiana CLOSE_BRACKET 
            {:
                System.out.println("triangleAreaMaximum: Completado");
            :};
            
lista_cartesiana ::= triangulo CA_PY triangulo;

triangulo ::= CA_CA punto CA_PY punto CA_PY punto CA_CC;

punto ::= eje:x CA_CO eje:y
            {:
                // x e y vienen como Simbolo (ver 'eje')
                String tx = ((Simbolo)x).getTipoDato();
                String ty = ((Simbolo)y).getTipoDato();

                // Solo se permiten coordenadas numéricas (Int o Float)
                boolean xNum = tx.equals("Int") || tx.equals("Float");
                boolean yNum = ty.equals("Int") || ty.equals("Float");
                if (!xNum || !yNum) {
                    throw new RuntimeException("Coordenadas no numéricas en punto: (" + tx + ", " + ty + ")");
                }

                System.out.println(((Simbolo)x).getNombre()+","+((Simbolo)y).getNombre());
            :};
            
eje ::= CONST_FLO:cf
            {:
                // Registrar constante Float con prefijo "_"
                String lex = cf.toString();
                String nombre = "_" + lex;
                if (!action_obj.symbolTable.containsSymbol(nombre)) {
                    action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "Float", lex, null));
                }
                // Propagar como Simbolo tipado
                RESULT = new Simbolo(nombre, "Float", lex, null);
            :}
        | INTEGER_CONSTANT:ci
            {:
                // Registrar constante Int con prefijo "_"
                String lex = ci.toString();
                String nombre = "_" + lex;
                if (!action_obj.symbolTable.containsSymbol(nombre)) {
                    action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "Int", lex, null));
                }
                RESULT = new Simbolo(nombre, "Int", lex, null);
            :}
        | IDENTIFIER:id
            {:
                // Debe existir en TS y ser numérica
                Simbolo s = action_obj.symbolTable.getSymbol(id.toString());
                if (s == null) {
                    throw new RuntimeException("Identificador no declarado en coordenada: " + id);
                }
                String t = s.getTipoDato();
                if (!(t.equals("Int") || t.equals("Float"))) {
                    throw new RuntimeException("Identificador no numérico en coordenada: " + id + " de tipo " + t);
                }
                RESULT = s;
            :};

// ========================================================================== //
// ================ X: convDate
// ========================================================================== //

/*        
convDate
Se desea implementar una función llamada convDate que convierta una fecha representada 
por tres números enteros (día, mes y año) en un único valor numérico con el formato YYYYMMDD.
CONV(22-03-2021) = 20210322
*/
sentence ::= CONV OPEN_BRACKET fecha CLOSE_BRACKET {: System.out.println("ConvDate: Completado"); :};
fecha ::= dia SUB mes SUB anio;
dia ::= INTEGER_CONSTANT;
mes ::= INTEGER_CONSTANT;
anio ::= INTEGER_CONSTANT;
