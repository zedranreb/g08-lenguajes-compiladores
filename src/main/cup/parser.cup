package lyc.compiler;

import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import java_cup.runtime.*;
import lyc.compiler.table.*;
import lyc.compiler.model.*;

import lyc.compiler.tercetos.*;
import lyc.compiler.files.*;
import java.util.Stack;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
class Parser;

action code
{:
    /**** Tabla de simbolos ****/
    public SymbolTable symbolTable = new SymbolTable();
    public ArrayList<Simbolo> symbolList = new ArrayList<>();

    /**** Tercetos ****/
    public ArrayList<Tercetos> listaDeTercetos = new ArrayList<>();
    public Stack<Integer> tercetoStack = new Stack<>();
    public Stack<Integer> numerosDeTercetosStack = new Stack<>();

    public IntermediateCodeGenerator intermediateCode = new IntermediateCodeGenerator(listaDeTercetos);
    public ManejadorTercetos manejador_Tercetos = new ManejadorTercetos();
    
    Map<Integer, String> mapaTiposTercetos = new HashMap<>();
    public int indexTerceto = 1;
    public int indexTercetoInicial;
    String operadorContrario = "";
    public int terceto_salto = 0;
    private char puntoTAM = 'A';

    public String invertirOperador(String operador) {
    switch (operador) {
        case "BGE": return "BLT";  // Mayor o igual -> Menor
        case "BLE": return "BGT";  // Menor o igual -> Mayor
        case "BGT": return "BLE";  // Mayor -> Menor o igual
        case "BLT": return "BGE";  // Menor -> Mayor o igual
        case "BEQ": return "BNE";  // Igual -> No igual
        case "BNE": return "BEQ";  // No igual -> Igual
        default: throw new RuntimeException("Operador no válido para inversión: " + operador);
    }
}
:}

parser code
{:
    public ArrayList<Simbolo> getSymbolTable() { 
        return action_obj.symbolTable.getSymbolTable();
    }

    public ArrayList<Tercetos> getIntermediateCode() {
            return action_obj.manejador_Tercetos.getIntermediateCode();
    }

:}

// Terminals
terminal ASSIG;
terminal PLUS;
terminal SUB;
terminal MULT;
terminal DIV;
terminal OPEN_BRACKET;
terminal CLOSE_BRACKET;
terminal INTEGER_CONSTANT;
terminal IDENTIFIER;
terminal DATE_CONVERTED;
terminal CA_CA;					
terminal CA_CC;					
terminal CA_LA;					
terminal CA_LC;					
terminal CA_CO;					
terminal CA_DP;					
terminal CA_PY;
terminal CP_BITT;
terminal CP_BITF;
terminal CA_COM;		

terminal CP_MEN;					
terminal CP_MENI;					
terminal CP_MAY;					
terminal CP_MAYI;					
terminal CP_IGUA;					
terminal CP_DIST;					
terminal CP_Y;					
terminal CP_O;					
terminal CP_NO;					
terminal CONST_STR;              
terminal CONST_FLO;             	
                
terminal INT;						
terminal FLOAT;					
terminal STRING;					
terminal INI;						
terminal IF;						
terminal ELSE;					
terminal WRITE;					
terminal READ;					
terminal WHILE;					
terminal TAM;						
terminal CONV;

// Non Terminals
non terminal programa;
non terminal iniciar;
non terminal lista_sentencia;
non terminal lista_declaracion;
non terminal declaracion;
non terminal lista_ids;
non terminal tipo_dato;
non terminal sentence;
non terminal assignment;
non terminal expression;
non terminal term;
non terminal factor;
non terminal condicion;
non terminal conjunto_condicion;
non terminal condicion_simple;
non terminal condicion_multiple;
non terminal condicion_negada;
non terminal operador_logico;
non terminal escribe;
non terminal lista_cartesiana;
non terminal triangulo;
non terminal punto;
non terminal eje;
non terminal fecha;
non terminal dia;
non terminal mes;
non terminal anio;

/*
	TEMAS COMUNES:
	A: While
	B: If / if - else
	C: Asignaciones
	D: Operaciones Aritméticas
	E: Tipos de datos
	F: Declaración de variables
	G: Entrada y salida
	H: Condiciones

	TEMAS ESPECIALES
	Z: triangleAreaMaximum
	X: convDate
*/

// ========================================================================== //
// ================ Comienzo del programa
// ========================================================================== //
start with programa;

programa ::= iniciar lista_sentencia;
// ========================================================================== //
// ================ F: Declaración de variables
// ========================================================================== //

iniciar ::= INI CA_LA lista_declaracion CA_LC
{:System.out.println("Inicializacion: completado");:};

lista_declaracion ::= lista_declaracion declaracion | 
					declaracion;

declaracion ::= lista_ids CA_DP tipo_dato
{: System.out.println("Declaracion: completado"); :};

lista_ids ::= lista_ids CA_CO IDENTIFIER:id
{: 
// Verificar si la variable ya está en la tabla de símbolos
    if (action_obj.symbolTable.containsSymbol(id.toString())) {
        throw new RuntimeException("Error: La variable '" + id.toString() + "' ya está declarada.");
    }

    // Crear y agregar la nueva variable
    Simbolo symbol = new Simbolo(id.toString(), "", "", null);
    this.symbolList.add(symbol);
    System.out.println("Se inicializó la variable: " + id.toString());
 :} | 
				IDENTIFIER:id
				{: 
				// Verificar si la variable ya está en la tabla de símbolos
				if (action_obj.symbolTable.containsSymbol(id.toString())) {
					throw new RuntimeException("Error: La variable '" + id.toString() + "' ya está declarada.");
				}

				// Crear y agregar la nueva variable
				Simbolo symbol = new Simbolo(id.toString(), "", "", null);
				this.symbolList.add(symbol);
				System.out.println("Se inicializó la variable: " + id.toString());
				:};
			
lista_sentencia ::= lista_sentencia sentence | 
				sentence;

// ========================================================================== //
// ================ C: Asignaciones
// ========================================================================== //

sentence ::= assignment;
assignment ::= IDENTIFIER:id ASSIG expression:e
{:
    // Validar existencia de la variable LHS
    Simbolo var = action_obj.symbolTable.getSymbol(id.toString());
    if (var == null) {
        throw new RuntimeException("La variable '" + id + "' no fue declarada.");
    }
    // Validar que la expresión haya propagado un Simbolo tipado
    if (e == null) {
        throw new RuntimeException("Expresión nula en asignación a '" + id + "'.");
    }


    String tVar = var.getTipoDato();
    String tExp = ((Simbolo)e).getTipoDato();
    if(tVar.equals("DATE_CONVERTED") && tExp.equals("String")){
        throw new RuntimeException("Type mismatch: no se puede asignar " + tExp + " a variable " + id + " de tipo " + tVar);
    }
    if (!tExp.equals("DATE_CONVERTED") && !tVar.equals("DATE_CONVERTED") && !tVar.equals(tExp)) {
        throw new RuntimeException("Type mismatch: no se puede asignar " + tExp + " a variable " + id + " de tipo " + tVar);
    }


    int indiceExpresion = action_obj.manejador_Tercetos.obtenerIndice("expression");
    String tipoExpresion = mapaTiposTercetos.get(indiceExpresion); 

    // Realizar el cambio del tipo de dato en el mapa si es necesario
    if (!tVar.equals(tipoExpresion)) {
        System.out.println("Realizando conversión implícita de " + tipoExpresion + " a " + tVar);

        // Actualizar el tipo de dato en el mapa para reflejar el cambio implícito
        mapaTiposTercetos.put(indiceExpresion, tVar);
        if(tVar == "Int"){
             action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "TRUNC", "[" + indiceExpresion + "]", "_");
             indexTerceto++;
        }
    }

    // Generar el terceto de asignación
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, ":=", "[" + indiceExpresion + "]", id.toString());
    mapaTiposTercetos.put(indexTerceto, tVar); // Asignar el tipo de la variable destino al nuevo terceto
    indexTerceto++;

    System.out.println("Asignacion de : " + id);
:};

// ========================================================================== //
// ================ D: Operaciones Aritméticas
// ========================================================================== //
expression ::= expression:e1 PLUS term:e2
{:
    // Crear el terceto de suma
    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto, "+", "[" + action_obj.manejador_Tercetos.obtenerIndice("expression") + "]", "[" + action_obj.manejador_Tercetos.obtenerIndice("term") + "]"));
    

    // Validar los tipos de los operandos
    String tipoE1 = mapaTiposTercetos.get(action_obj.manejador_Tercetos.obtenerIndice("expression"));
    String tipoE2 = mapaTiposTercetos.get(action_obj.manejador_Tercetos.obtenerIndice("term"));
    
    if (tipoE1.equals(tipoE2)) {
        // Asignar tipo al terceto de suma
        mapaTiposTercetos.put(indexTerceto, tipoE1);
    } else {
        throw new RuntimeException("Type mismatch: No se puede sumar " + tipoE1 + " con " + tipoE2);
    }
    action_obj.manejador_Tercetos.agregarIndice("expression", indexTerceto);

    indexTerceto++;
    RESULT = new Simbolo("", tipoE1, "", null);
:};
expression ::= expression:e1 SUB term:e2
{:

// Crear el terceto de resta
    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto, "-", "[" + action_obj.manejador_Tercetos.obtenerIndice("expression") + "]", "[" + action_obj.manejador_Tercetos.obtenerIndice("term") + "]"));
    
      // Validar los tipos de los operandos
    String tipoE1 = mapaTiposTercetos.get(action_obj.manejador_Tercetos.obtenerIndice("expression"));
    String tipoE2 = mapaTiposTercetos.get(action_obj.manejador_Tercetos.obtenerIndice("term"));
    
    if (tipoE1.equals(tipoE2)) {
        // Asignar tipo al terceto de resta
        mapaTiposTercetos.put(indexTerceto, tipoE1);
    } else {
        if(tipoE2=="Float"){
            System.out.println("Realizando conversión implícita de " + tipoE1 + " a " + tipoE2);
            mapaTiposTercetos.put(indexTerceto, tipoE2);}
        else{
            System.out.println("Realizando conversión implícita de " + tipoE2 + " a " + tipoE1);
            mapaTiposTercetos.put(indexTerceto, tipoE1);
            }
    }

    

    mapaTiposTercetos.put(indexTerceto, tipoE1);
    action_obj.manejador_Tercetos.agregarIndice("expression", indexTerceto);   

    indexTerceto++;
    RESULT = new Simbolo("", tipoE1, "", null);
:};
expression ::= term:t
{:
    action_obj.manejador_Tercetos.apuntarAOtroIndice("expression", "term");
    RESULT = t;
:};
term ::= term:t MULT factor:f
{:
   // Crear el terceto de multiplicación
    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto, "*", "[" + action_obj.manejador_Tercetos.obtenerIndice("term") + "]", "[" + action_obj.manejador_Tercetos.obtenerIndice("factor") + "]"));
    

    // Validar los tipos de los operandos
    String tipoT = mapaTiposTercetos.get(action_obj.manejador_Tercetos.obtenerIndice("term"));
    String tipoF = mapaTiposTercetos.get(action_obj.manejador_Tercetos.obtenerIndice("factor"));
    

    if (tipoT.equals(tipoF)) {
        // Asignar tipo al terceto de resta
        mapaTiposTercetos.put(indexTerceto, tipoT);
    } else {
        if(tipoT=="Float"){
            System.out.println("Realizando conversión implícita de " + tipoF + " a " + tipoT);
            mapaTiposTercetos.put(indexTerceto, tipoT);}
        else{
            System.out.println("Realizando conversión implícita de " + tipoT + " a " + tipoF);
            mapaTiposTercetos.put(indexTerceto, tipoF);
            }
    }
    action_obj.manejador_Tercetos.agregarIndice("term", indexTerceto);
    indexTerceto++;
    RESULT = new Simbolo("", tipoT, "", null);
:};
term ::= term:t DIV factor:f
{:
     // Crear el terceto de división
    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto, "/", "[" + action_obj.manejador_Tercetos.obtenerIndice("term") + "]", "[" + action_obj.manejador_Tercetos.obtenerIndice("factor") + "]"));
    
    // Validar los tipos de los operandos
    String tipoT = mapaTiposTercetos.get(action_obj.manejador_Tercetos.obtenerIndice("term"));
    String tipoF = mapaTiposTercetos.get(action_obj.manejador_Tercetos.obtenerIndice("factor"));
    
    
    if (tipoT.equals(tipoF)) {
        // Asignar tipo al terceto de resta
        mapaTiposTercetos.put(indexTerceto, tipoT);
    } else {
        if(tipoT=="Float"){
            System.out.println("Realizando conversión implícita de " + tipoF + " a " + tipoT);
            mapaTiposTercetos.put(indexTerceto, tipoT);}
        else{
            System.out.println("Realizando conversión implícita de " + tipoT + " a " + tipoF);
            mapaTiposTercetos.put(indexTerceto, tipoF);
            }
    }
    action_obj.manejador_Tercetos.agregarIndice("term", indexTerceto);
    indexTerceto++;
    RESULT = new Simbolo("", tipoT, "", null);
:};
term ::= factor:f
{:
    action_obj.manejador_Tercetos.apuntarAOtroIndice("term", "factor");
    RESULT = f;
:};
factor ::= IDENTIFIER:id
{:
    // Lookup de variable
    Simbolo s = action_obj.symbolTable.getSymbol(id.toString());
    if (s == null) {
        throw new RuntimeException("La variable '" + id + "' no fue declarada.");
    }

    // Crear el terceto y asignar el tipo de dato desde la tabla de símbolos
    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto, id.toString(), "_", "_"));
    action_obj.manejador_Tercetos.agregarIndice("factor", indexTerceto);
    
    // Asignar tipo al terceto
    mapaTiposTercetos.put(indexTerceto, s.getTipoDato());
    indexTerceto++;
    RESULT = s;
    System.out.println("Id: " + id);
:};
factor ::= INTEGER_CONSTANT:constant
{:
    // Registrar constante entera con prefijo "_"
    String lex = constant.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "Int", lex, null));
    }

     // Crear el terceto y asignar tipo de dato "Int"
    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto, constant.toString(), "_", "_"));
    action_obj.manejador_Tercetos.agregarIndice("factor", indexTerceto);
    mapaTiposTercetos.put(indexTerceto, "Int");
    
    indexTerceto++;
    RESULT = new Simbolo(nombre, "Int", lex, null);
    System.out.println("Entero: " + constant );
:};
factor ::= CONST_FLO:f
{:
    String lex = f.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "Float", lex, null));
    }

    // Crear el terceto y asignar tipo de dato "Float"
    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto, f.toString(), "_", "_"));
    action_obj.manejador_Tercetos.agregarIndice("factor", indexTerceto);
    mapaTiposTercetos.put(indexTerceto, "Float"); 
    
    indexTerceto++;

    RESULT = new Simbolo(nombre, "Float", lex, null);
    System.out.println("Flotante: " + f );
:};
factor ::= CONST_STR:s
{:
   

    String lex = s.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "String", lex, lex.length()-2));
    }

    // Crear el terceto
    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto, nombre, "_", "_"));
    action_obj.manejador_Tercetos.agregarIndice("factor", indexTerceto);
    mapaTiposTercetos.put(indexTerceto, "String");
    
    indexTerceto++;
    RESULT = new Simbolo(nombre, "String", lex, lex.length()-2);
    System.out.println("Cadena: " + s );
:};
factor ::= OPEN_BRACKET expression:e CLOSE_BRACKET
{:
    RESULT = e;
    System.out.println("(Expression)");
:};


/* === Agregados para usar las funciones en expresiones ===
   No se crean entradas en la TS; solo se retorna un Simbolo con el tipo correcto.
   Esto permite, por ejemplo: a = CONV(12-12-2025) y x = TAM([...]) en contextos aritméticos.
*/

// triangleAreaMaximum -> resultado numérico (usamos Float)
factor ::= TAM OPEN_BRACKET lista_cartesiana CLOSE_BRACKET
{:
    // 'lista_cartesiana' ya valida que las coordenadas sean Int/Float y que los IDs existan.
    int indiceTriangulo1 = action_obj.manejador_Tercetos.obtenerIndice("triangulo1");
    int indiceTriangulo2 = action_obj.manejador_Tercetos.obtenerIndice("triangulo2");

    // Realizar la validacion de cual es el triangulo con mayor area
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "CMP", "[" + indiceTriangulo1 + "]", "[" + indiceTriangulo2 + "]");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "BGE", "_", "_");
    numerosDeTercetosStack.push(indexTerceto);
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, ":=", "[" + indiceTriangulo2 + "]", "@aux");
    action_obj.manejador_Tercetos.modificarTerceto(numerosDeTercetosStack.pop(),2,"[" + (indexTerceto + 2) + "]");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "BI", "_", "_");
    numerosDeTercetosStack.push(indexTerceto);
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, ":=", "[" + indiceTriangulo1 + "]", "@aux");
    action_obj.manejador_Tercetos.modificarTerceto(numerosDeTercetosStack.pop(),2,"[" + (indexTerceto + 1) + "]");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@aux", "_", "_");
    action_obj.manejador_Tercetos.agregarIndice("factor", indexTerceto);
    mapaTiposTercetos.put(indexTerceto, "Float");
    indexTerceto++;

    RESULT = new Simbolo("triangleAreaMaximumResult", "Float", "", 0);
    System.out.println("triangleAreaMaximum usado como factor");
:};

// convDate -> entero YYYYMMDD
factor ::= CONV OPEN_BRACKET fecha CLOSE_BRACKET
{:
    // 'fecha' se define como dia SUB mes SUB anio; tokens enteros.
    action_obj.manejador_Tercetos.apuntarAOtroIndice("factor","convdate");
    mapaTiposTercetos.put(indexTerceto-1, "DATE_CONVERTED");
    //mapaTiposTercetos.put(indexTerceto, tVar); // Asignar el tipo de la variable destino al nuevo terceto
    RESULT = new Simbolo("convDate", "DATE_CONVERTED", "", 0);
    System.out.println("convDate usado como factor");
:};

// ========================================================================== //
// ================ H: Condiciones
// ========================================================================== //

condicion ::= OPEN_BRACKET conjunto_condicion CLOSE_BRACKET
{:
    System.out.println("Condicion: completado");
:};

conjunto_condicion ::= condicion_simple
                    | condicion_multiple
                    | condicion_negada;

condicion_simple ::= expression:e1 {:tercetoStack.push(indexTerceto - 1);:} operador_logico expression:e2
{:
     int indiceExpr2 = indexTerceto -1; 
    int indiceExpr1 = tercetoStack.pop(); 

    String tipoFactor1 = mapaTiposTercetos.get(indiceExpr1);
    String tipoFactor2 = mapaTiposTercetos.get(indiceExpr2);

    // Verificar si los tipos de datos son compatibles
    if (tipoFactor1 == null || tipoFactor2 == null) {
        throw new RuntimeException("Error: Uno de los tipos de los factores no está definido.");
    }

    if (!tipoFactor1.equals(tipoFactor2)) {
        throw new RuntimeException("Type mismatch: No se puede comparar un " + tipoFactor1 + " con un " + tipoFactor2);
    }

    System.out.println("Condición simple con tipos compatibles: " + tipoFactor1 + " y " + tipoFactor2);

    
    int indiceComparacion = action_obj.manejador_Tercetos.getIntermediateCode().size() + 1;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "CMP", "[" + indiceExpr1 + "]", "[" + indiceExpr2 + "]");
    mapaTiposTercetos.put(indiceComparacion, "bool");
    indexTerceto++;


    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, operadorContrario, "_", "_");
    numerosDeTercetosStack.push(indexTerceto);
    indexTerceto++;
:};

condicion_multiple ::= condicion_simple:cs CP_Y condicion_simple 
{:
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "BI", "[" + Integer.toString(indexTerceto+2 ) + "]", "_");
    indexTerceto++;

    int saltoSegundaCondicion = numerosDeTercetosStack.pop();
    action_obj.manejador_Tercetos.modificarTerceto(saltoSegundaCondicion, 2, "[" + Integer.toString(indexTerceto) + "]");
    int saltoPrimeraCondicion = numerosDeTercetosStack.pop();
    action_obj.manejador_Tercetos.modificarTerceto(saltoPrimeraCondicion, 2, "[" + Integer.toString(indexTerceto) + "]");



    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "BI", "_", "_");
    numerosDeTercetosStack.push(indexTerceto);
    indexTerceto++;
    System.out.println("Condicion Multiple con AND");
:}
                    |  condicion_simple:cs 
{:
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "BI", "_", "_");
    numerosDeTercetosStack.push(indexTerceto);
    indexTerceto++;
:} 
CP_O condicion_simple 
{:
    int saltoSegundaCondicion = numerosDeTercetosStack.pop();
    int saltoBI = numerosDeTercetosStack.pop();

    action_obj.manejador_Tercetos.modificarTerceto(saltoBI, 2, "[" + Integer.toString(indexTerceto) + "]");
    int saltoPrimeraCondicion = numerosDeTercetosStack.pop();
    action_obj.manejador_Tercetos.modificarTerceto(saltoPrimeraCondicion, 2, "[" + Integer.toString(saltoPrimeraCondicion+2) + "]");

    numerosDeTercetosStack.push(saltoSegundaCondicion);

    System.out.println("Condicion Multiple con OR");
:};

condicion_negada ::= CP_NO condicion_simple
{:
    System.out.println("Condicion Simple Negada");
:};

operador_logico ::= CP_MEN {: operadorContrario = "BGE";  System.out.println("Operador: <"); :} |
CP_MENI {: operadorContrario = "BGT"; System.out.println("Operador: <="); :}         | 
CP_MAY {: operadorContrario = "BLE"; System.out.println("Operador: >"); :}           |
CP_MAYI {: operadorContrario = "BLT"; System.out.println("Operador: >="); :}         |
CP_IGUA {: operadorContrario = "BNE"; System.out.println("Operador: =="); :}         |
CP_DIST {: operadorContrario = "BEQ"; System.out.println("Operador: !="); :};

// ========================================================================== //
// ================ G: Entrada y salida
// ========================================================================== //
sentence ::= READ OPEN_BRACKET IDENTIFIER:id CLOSE_BRACKET
{:
    // Validar existencia del identificador
    if (!action_obj.symbolTable.containsSymbol(id.toString())) {
        throw new RuntimeException("READ sobre variable no declarada: " + id);
    }

    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto,"READ" ,  id.toString(),"_"));
    indexTerceto++;
    System.out.println("READ: " + id + " completado");
:};


sentence ::= WRITE OPEN_BRACKET escribe CLOSE_BRACKET
{:
    
    System.out.println("WRITE: completado");
:};

escribe ::= CONST_STR:s
{:
    // Registrar la constante string con prefijo "_"
    String lex = s.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "String", lex, lex.length()-2));
    }

    // Crear el terceto
    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto,"WRITE" ,s.toString(), "_"));
 
    indexTerceto++;

    System.out.println("Cadena: " + s);
:}
          | IDENTIFIER:id
{:
    if (!action_obj.symbolTable.containsSymbol(id.toString())) {
        throw new RuntimeException("WRITE sobre variable no declarada: " + id);
    }

    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto,"WRITE" , id.toString() ,"_"));
    indexTerceto++;
    System.out.println("Id: " + id);
:};
			
// ========================================================================== //
// ================ B: If / if - else
// ========================================================================== //
sentence ::= IF condicion CA_LA lista_sentencia CA_LC 
{:
    int nroTercetoDesapilado = numerosDeTercetosStack.pop();
    action_obj.manejador_Tercetos.modificarTerceto(nroTercetoDesapilado, 2 ,"[" + Integer.toString(indexTerceto) +"]");
    System.out.println("IF: completado");
:}
            | IF condicion CA_LA lista_sentencia CA_LC 
{:
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "BI", "_", "_");
    indexTerceto++;
    int nroTercetoDesapilado = numerosDeTercetosStack.pop();
    action_obj.manejador_Tercetos.modificarTerceto(nroTercetoDesapilado, 2 ,"[" + Integer.toString(indexTerceto) +"]");

    numerosDeTercetosStack.push(indexTerceto-1);

:}            
ELSE CA_LA lista_sentencia CA_LC
{:
    System.out.println("If - Else");
    int nroTercetoDesapilado = numerosDeTercetosStack.pop();

    action_obj.manejador_Tercetos.modificarTerceto(nroTercetoDesapilado, 2 ,"[" + Integer.toString(indexTerceto ) +"]");
    System.out.println("IF / ELSE: completado");
:};

// ========================================================================== //
// ================ A: While
// ========================================================================== //

sentence ::= WHILE 
{:
numerosDeTercetosStack.push(indexTerceto);
:}

condicion CA_LA lista_sentencia CA_LC 
{:
    System.out.println("Bucle While");
    int nroTercetoDesapilado= numerosDeTercetosStack.pop();
    action_obj.manejador_Tercetos.modificarTerceto(nroTercetoDesapilado, 2 ,"[" + Integer.toString(indexTerceto +1) +"]");


    nroTercetoDesapilado = numerosDeTercetosStack.pop();

    action_obj.manejador_Tercetos.agregarTerceto(new Tercetos(indexTerceto, "BI", "[" + Integer.toString(nroTercetoDesapilado)+"]", "_"));
    indexTerceto++;
    System.out.println("WHILE: completado");
:};


// ========================================================================== //
// ================ E: Tipos de datos
// ========================================================================== //

tipo_dato ::= INT:i {: System.out.println("int" );
			action_obj.symbolTable.addNewSymbols(this.symbolList, "Int");
			this.symbolList.clear();  :} 
			| FLOAT:f {: System.out.println("float"); 
			action_obj.symbolTable.addNewSymbols(this.symbolList, "Float");
			this.symbolList.clear(); :} 
			| STRING:s {: System.out.println("string"); 
			action_obj.symbolTable.addNewSymbols(this.symbolList, "String");
			this.symbolList.clear(); :}
			| DATE_CONVERTED:d {: System.out.println("DATE_CONVERTED"); 
			action_obj.symbolTable.addNewSymbols(this.symbolList, "DATE_CONVERTED");
			this.symbolList.clear(); :} ;


// ========================================================================== //
// ================ Z: triangleAreaMaximum
// ========================================================================== //
/*
triangleAreaMaximum

Se desea implementar una función llamada triangleAreaMaximum que, dadas las 
coordenadas de dos triángulos en el plano cartesiano, determine cuál de los 
dos tiene mayor área y devuelva dicho valor numérico.

La función recibirá dos triángulos, cada uno definido por las coordenadas 
de sus vértices en el plano cartesiano. Dichas coordenadas pueden ser 
Constantes o Variables, enteras o flotantes.
*/
sentence ::= TAM OPEN_BRACKET lista_cartesiana CLOSE_BRACKET 
            {:
                System.out.println("triangleAreaMaximum: Completado");
/*              action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "CMP", "@Atr1", "@ATr2");
                indexTerceto++;    

                action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "CMP", "@Atr1", "@ATr2");
                indexTerceto++;  */ 

            :};
            
lista_cartesiana ::= triangulo 
        {:
            System.out.println("Area del primer triangulo calcuda");
            action_obj.manejador_Tercetos.agregarIndice("triangulo1", indexTerceto - 1);

        :}
    CA_PY 
triangulo
        {:
            System.out.println("Area del segundo triangulo calcuda");
            action_obj.manejador_Tercetos.agregarIndice("triangulo2", indexTerceto - 1);
        :};

triangulo ::= CA_CA punto CA_PY punto CA_PY punto CA_CC 
{:
    // Calcular vector AB
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@Bx", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@Ax", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "-", "[" + (indexTerceto - 2) + "]", "[" + (indexTerceto - 1) + "]");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, ":=", "[" + (indexTerceto - 1) + "]", "@vABx");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@By", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@Ay", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "-", "[" + (indexTerceto - 2) + "]", "[" + (indexTerceto - 1) + "]");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, ":=", "[" + (indexTerceto - 1) + "]", "@vABy");
    indexTerceto++;

    // Calcular vector AC
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@Cx", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@Ax", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "-", "[" + (indexTerceto - 2) + "]", "[" + (indexTerceto - 1) + "]");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, ":=", "[" + (indexTerceto - 1) + "]", "@vACx");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@Cy", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@Ay", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "-", "[" + (indexTerceto - 2) + "]", "[" + (indexTerceto - 1) + "]");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, ":=", "[" + (indexTerceto - 1) + "]", "@vACy");
    indexTerceto++;
    
    // Calcular area
    // Area triangulo = abs((@vACx,@vACy).(-@vABy,@vABx))/2 --> abs(@vACx * @vABy * (-1) + @vACy * @vABx)/2

    // @vACx * @vABy * (-1)
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@vABy", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "-1", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "*", "[" + (indexTerceto - 2) + "]", "[" + (indexTerceto - 1) + "]");
    indexTerceto++;
    
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@vACx", "_" , "_");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "*", "[" + (indexTerceto - 2) + "]", "[" + (indexTerceto - 1) + "]");
    indexTerceto++;

    //  @vACy * @vABx
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@vACy", "_" , "_");
    indexTerceto++;
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@vABx", "_" , "_");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "*", "[" + (indexTerceto - 2) + "]", "[" + (indexTerceto - 1) + "]");
    indexTerceto++;

    // @vACx * @vABy * (-1) + @vACy * @vABx
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "+", "[" + (indexTerceto - 4) + "]", "[" + (indexTerceto - 1) + "]");
    indexTerceto++;
    
    // abs( @vACx * @vABy * (-1) + @vACy * @vABx) 
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "ABS", "[" + (indexTerceto - 1) + "]", "_");
    indexTerceto++;

    // abs( @vACx * @vABy * (-1) + @vACy * @vABx) / 2
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "2", "_", "_");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "/", "[" + (indexTerceto - 2) + "]", "[" + (indexTerceto - 1) + "]");
    indexTerceto++;

    // Reiniciar el punto
    puntoTAM = 'A';
    
:};

punto ::= eje:x CA_CO eje:y
{:
    // x e y vienen como Simbolo (ver 'eje')
    String tx = ((Simbolo)x).getTipoDato();
    String ty = ((Simbolo)y).getTipoDato();

    // Solo se permiten coordenadas numéricas (Int o Float)
    boolean xNum = tx.equals("Int") || tx.equals("Float") ||  tx.equals("CONST_INT") || tx.equals("CONST_FLOAT");
    boolean yNum = ty.equals("Int") || ty.equals("Float") ||  ty.equals("CONST_INT") || ty.equals("CONST_FLOAT");
    if (!xNum || !yNum) {
        throw new RuntimeException("Coordenadas no numéricas en punto: (" + tx + ", " + ty + ")");
    }

    String valorX, valorY;
    if(((Simbolo)x).getNombre().charAt(0) == '_') {
        valorX = ((Simbolo)x).getValor();
    } else {
        valorX = ((Simbolo)x).getNombre();
    }

    if(((Simbolo)y).getNombre().charAt(0) == '_') {
        valorY = ((Simbolo)y).getValor();
    } else {
        valorY = ((Simbolo)y).getNombre();
    }

    /* TERCETO */
    // Incorporar el valor de x, la variable acumuladora, el valor de y la variable acumuladora y sus respectiva sumas
    // x
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, valorX, "_" , "_");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@" + puntoTAM + "x", "_" , "_");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "+", "[" + (indexTerceto - 1) + "]", "[" + (indexTerceto - 2) + "]");
    indexTerceto++;

    // Incorporar el valor de x, la variable acumuladora, el valor de y la variable acumuladora y sus respectiva sumas
    // y
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, valorY, "_" , "_");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "@" + puntoTAM + "y", "_" , "_");
    indexTerceto++;

    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "+", "[" + (indexTerceto - 1) + "]", "[" + (indexTerceto - 2) + "]");
    indexTerceto++;

    System.out.println("Punto ("+ puntoTAM +"): " + valorX + "," + valorY);
    puntoTAM++;
:};
            
eje ::= CONST_FLO:cf
            {:
                // Registrar constante Float con prefijo "_"
                String lex = cf.toString();
                String nombre = "_" + lex;
                if (!action_obj.symbolTable.containsSymbol(nombre)) {
                    action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "Float", lex, null));
                }
                Simbolo sim = action_obj.symbolTable.getSymbol(nombre);
                // Propagar como Simbolo tipado
                RESULT = sim;
            :}
        | INTEGER_CONSTANT:ci
            {:
                // Registrar constante Int con prefijo "_"
                String lex = ci.toString();
                String nombre = "_" + lex;
                if (!action_obj.symbolTable.containsSymbol(nombre)) {
                    action_obj.symbolTable.addNewSymbols(new Simbolo(nombre, "Int", lex, null));
                }
                
                Simbolo sim = action_obj.symbolTable.getSymbol(nombre);
                // Propagar como Simbolo tipado
                RESULT = sim;
            :}
        | IDENTIFIER:id
            {:
                // Debe existir en TS y ser numérica
                Simbolo s = action_obj.symbolTable.getSymbol(id.toString());
                if (s == null) {
                    throw new RuntimeException("Identificador no declarado en coordenada: " + id);
                }
                String t = s.getTipoDato();
                if (!(t.equals("Int") || t.equals("Float"))) {
                    throw new RuntimeException("Identificador no numérico en coordenada: " + id + " de tipo " + t);
                }
                RESULT = s;
            :};

// ========================================================================== //
// ================ X: convDate
// ========================================================================== //

/*        
convDate
Se desea implementar una función llamada convDate que convierta una fecha representada 
por tres números enteros (día, mes y año) en un único valor numérico con el formato YYYYMMDD.
CONV(22-03-2021) = 20210322
*/
sentence ::= CONV OPEN_BRACKET fecha CLOSE_BRACKET {: System.out.println("ConvDate: Completado"); :};
fecha ::= dia:dia SUB mes:mes SUB anio:anio {:
    // Validar fecha correcta
    int[] diasDelMes = {31,28,31,30,31,30,31,31,30,31,30,31};
    Integer resAnio = Integer.parseInt(((Simbolo)anio).getValor());
    Integer resMes = Integer.parseInt(((Simbolo)mes).getValor());
    Integer resDia = Integer.parseInt(((Simbolo)dia).getValor());
    
    // Validación fecha correcta
    if( ( resAnio % 4 == 0 && resAnio % 100 != 0) || resAnio % 400 == 0 )
        diasDelMes[2-1] = diasDelMes[2-1] + 1;
    
    if ( resMes > 12 || resMes < 1)
        throw new RuntimeException("ERROR: Mes invalido.");
    
    if ( resDia > diasDelMes[resMes - 1] || resDia < 1)
        throw new RuntimeException("ERROR: Dia invalido.");

    /* TERCETO */
    // Incorporar los tercetos para la sumas de las multiplicaciones individuales
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "+", "[" + (indexTerceto - 1) + "]", "[" + (indexTerceto - 3) + "]");
    indexTerceto++;

    /* Incorporar terceto multiplicar anio por 1000 */
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "+", "[" + (indexTerceto - 1) + "]", "[" + (indexTerceto - 6) + "]");
    action_obj.manejador_Tercetos.agregarIndice("convdate", indexTerceto);
    indexTerceto++;
:};

dia ::= INTEGER_CONSTANT:dia {:
    // Registrar constante Float con prefijo "_" en tabla de simbolos
    String lex = dia.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        Simbolo nuevoSimbolo = new Simbolo(nombre, "Int", lex, null);
        action_obj.symbolTable.addNewSymbols(nuevoSimbolo);
    }
    Simbolo nuevoSimbolo = action_obj.symbolTable.getSymbol(nombre);
    /* TERCETO */
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, dia.toString(), "_", "_");
    indexTerceto++;
    
    RESULT = nuevoSimbolo;
:};
mes ::= INTEGER_CONSTANT:mes {:
    // Registrar constante Float con prefijo "_" en tabla de simbolos
    String lex = mes.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        Simbolo nuevoSimbolo = new Simbolo(nombre, "Int", lex, null);
        action_obj.symbolTable.addNewSymbols(nuevoSimbolo);
    }
    Simbolo nuevoSimbolo = action_obj.symbolTable.getSymbol(nombre);
    /* TERCETO */
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, mes.toString(), "_", "_");
    indexTerceto++;

    /* Incorporar terceto multiplicar mes por 100 */
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "*", "[" + (indexTerceto - 1) + "]", "100");
    indexTerceto++;

    RESULT = nuevoSimbolo;
:};
anio ::= INTEGER_CONSTANT:anio {:
    // Registrar constante Float con prefijo "_" en tabla de simbolos
    String lex = anio.toString();
    String nombre = "_" + lex;
    if (!action_obj.symbolTable.containsSymbol(nombre)) {
        Simbolo nuevoSimbolo = new Simbolo(nombre, "Int", lex, null);
        action_obj.symbolTable.addNewSymbols(nuevoSimbolo);
    }
    Simbolo nuevoSimbolo = action_obj.symbolTable.getSymbol(nombre);
    /* TERCETO */
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, anio.toString(), "_", "_");
    indexTerceto++;

    /* Incorporar terceto multiplicar anio por 1000 */
    action_obj.manejador_Tercetos.crearNuevoTerceto(indexTerceto, "*", "[" + (indexTerceto - 1) + "]", "1000");
    indexTerceto++;

    RESULT = nuevoSimbolo;
:};
